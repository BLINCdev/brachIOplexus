<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>inverse_kinematics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>inverse_kinematics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ikpy.chain import Chain
from ikpy.link import OriginLink, URDFLink
from mpl_toolkits.mplot3d import Axes3D
from math import pi
import matplotlib.pyplot as plt
from helper_functions import fill_state, get_diff_xyz, change_scale


class InverseKinematics:

    def __init__(self, robot_obj=None):
        &#34;&#34;&#34;
        This is the chain/urdf of the arm used for forward and inverse kinematics with the final end effector
        being the center of the end of the fixed chopstick.  All measurements are in centimeters and have been measured
        using the solidworks model.

        Args:
            robot_obj (Robot): Robot class which is needed for the joint min and max positions

        Attributes:
            bento_chain (Chain): IKPy Chain, a collection of links and __joints representing the bento arm
            max_error (float): Total allowable IK lookup error ( goal_position - position calculated by IK )
        &#34;&#34;&#34;

        if robot_obj is None:
            from robot import Robot
            self.robot = Robot()
        else:
            self.robot = robot_obj

        self.bento_chain = Chain(name=&#39;left_arm&#39;, links=[
            OriginLink(),
            URDFLink(
                name=&#34;base_to_post&#34;,
                origin_translation=[0, 0, 32],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;
            ),
            URDFLink(
                name=&#34;extender&#34;,
                origin_translation=[12, 0, 0],  # Careful this is set by the user
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;,
            ),
            URDFLink(
                name=&#34;shoulder&#34;,
                origin_translation=[0, 0, -6.99],
                origin_orientation=[pi, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 0, 1],
                bounds=(self.robot.get_joints()[0].radians_min, self.robot.get_joints()[0].radians_max)
            ),
            URDFLink(
                name=&#34;shoulder_to_elbow&#34;,
                origin_translation=[2.9, 0, 12.503],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 1, 0],
                bounds=(self.robot.get_joints()[1].radians_min, self.robot.get_joints()[1].radians_max)
            ),
            URDFLink(
                name=&#34;elbow_to_forearm&#34;,
                origin_translation=[15.123, 0, -0.225],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[1, 0, 0],
                bounds=(self.robot.get_joints()[2].radians_min, self.robot.get_joints()[2].radians_max)
            ),
            URDFLink(
                name=&#34;forearm_to_wrist&#34;,
                origin_translation=[4.38, 0, 0.065],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 1, 0],
                bounds=(self.robot.get_joints()[3].radians_min, self.robot.get_joints()[3].radians_max)
            ),
            URDFLink(
                name=&#34;wrist_to_hand&#34;,
                origin_translation=[8.43, 0, 0.073],
                origin_orientation=[pi, 0, 0],
                joint_type=&#34;fixed&#34;,
            ),
            URDFLink(
                name=&#34;hand_to_finger&#34;,
                origin_translation=[10.52, -0.092, 0],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;,
            ), ], active_links_mask=[False, False, False, True, True, True, True, False, False])

        # Ax for plotting
        self.ax = plt.figure().add_subplot(111, projection=&#39;3d&#39;)
        self.ax.axes.set_xlim3d(left=0, right=55)
        self.ax.axes.set_ylim3d(bottom=-22.5, top=22.5)
        self.ax.axes.set_zlim3d(bottom=0, top=55)

        # Safety params
        self.max_error = 0.1

    def plot_state(self, state=[0, 0, 0, 0]):
        &#34;&#34;&#34;
        Plots the Bento Arm in the given joint_positions in 3D

        Args:
            state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]

        Returns:
            None

        &#34;&#34;&#34;
        self.bento_chain.plot(fill_state(state), self.ax)
        plt.show(block=False)

    def forward_kinematics(self, state=[0, 0, 0, 0], matrix=False):
        &#34;&#34;&#34;
        Does a forward kinematics lookup taking a joint_positions and calculating where the end of the fixed chopstick is in space

        Args:
            state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]
            matrix (bool): If true end effector position gets returned as a homogenous matrix, else a XYZ tuple

        Returns:
            The end effectors position as homogenous matrix or XYZ tuple
        &#34;&#34;&#34;
        position = self.bento_chain.forward_kinematics(fill_state(state))
        if matrix:
            return position  # Return homogenous transform matrix
        else:
            return position[0][3], position[1][3], position[2][3]  # Return X Y Z coordinates

    def inverse_kinematics(self, target_position_xyz=(0, 0, 0), plot=True):
        &#34;&#34;&#34;
        A crude inverse kinematics lookup which estimates the joint positions needed to have the end effector reach a
        target position.  Will also check if the sum of the difference between goal and forward_kinematics calculation
        is greater than self.max_error if so will give an input warning.

        Args:
            target_position_xyz (tuple): Target XYZ position in space for end effector to touch
            plot (bool): If true will plot the joint configuration

        Returns:

        &#34;&#34;&#34;
        joints = self.bento_chain.inverse_kinematics(target_position_xyz)
        forward = self.forward_kinematics(joints)
        difference = []
        for i in range(3):
            difference.append(abs(target_position_xyz[i] - forward[i]))
        if sum(difference) &gt; self.max_error:
            input(f&#34;WARNING POSITION {target_position_xyz} REDUCED TO {forward} PRESS ENTER IF YOUR SURE!!!&#34;)
        if plot:
            self.plot_state(joints)
        return joints

    def get_end_effector_position(self):
        &#34;&#34;&#34;
        Converts the current joint positions read by the brachIOplexus packet / Robot class and calculates the position
        of the end effector in 3D space (cm)

        Returns:
            Tuple of position (cm) or Matrix

        &#34;&#34;&#34;
        if self.robot.normalized:
            joints_to_ik = [change_scale(old_min=0,
                                         old_max=1,
                                         new_min=self.robot.get_joints()[i].radians_min,
                                         new_max=self.robot.get_joints()[i].radians_max,
                                         value=self.robot.get_joints()[i].get_normalized_joint_position()) for i in range(4)]
        else:
            joints_to_ik = [change_scale(old_min=self.robot.DYNA_MIN,
                                         old_max=self.robot.DYNA_MAX,
                                         new_min=-pi,
                                         new_max=pi,
                                         value=self.robot.get_joints()[i].position) for i in range(4)]
        return self.forward_kinematics(joints_to_ik, matrix=False)

    def get_joints_for_goal_xyz(self, goal_xyz, hand_state=&#34;mid&#34;):
        &#34;&#34;&#34;
        Builds an action using the desired goal_xyz and hand_state

        Args:
            goal_xyz: XYZ goal position for end effector in cm
            hand_state: possible options include &#34;closed&#34;, &#34;mid&#34;, and &#34;open&#34;

        Returns:
            A collection of __joints required by the Robot class

        &#34;&#34;&#34;
        ik_radians = self.inverse_kinematics(goal_xyz)[3:8]
        ik_radians[-1] = self.robot.hand_states[hand_state]
        # IKPY returns in [-pi, pi], need in [0,4096] or [0,1]
        if self.robot.normalized:
            joints = [change_scale(old_min=self.robot.get_joints()[i].radians_min,
                                   old_max=self.robot.get_joints()[i].radians_max,
                                   new_min=0,
                                   new_max=1,
                                   value=ik_radians[i]) for i in range(5)]
            return joints

        else:
            return [change_scale(-pi, pi, self.robot.DYNA_MIN, self.robot.DYNA_MAX, i) for i in ik_radians]

def test_ik():
    &#34;&#34;&#34;
    Basic test_ik that does both forward and backwards kinematics for a collection of manually defined joint positions,
    asserting that the forward and kinematics position for the joint positions are roughly the same

    Returns:
        None
    &#34;&#34;&#34;
    # Basic test_ik doing both forward and backwards kinematics assuring both give the same value
    positions = [[0, 0, 0, 0], [pi / 2, 0, 0, pi / 2], [-pi / 2, 0, -pi / 2, -pi / 2]]
    ik = InverseKinematics()

    for pos in positions:
        ik.plot_state(pos)
        for_position = ik.forward_kinematics(pos)
        print(f&#39;Forward Kinematics Position: {for_position}&#39;)
        print(f&#39;Target: {pos}&#39;)
        state = ik.inverse_kinematics(target_position_xyz=for_position)
        print(f&#39;Required State Radians {state[3:7]}&#39;)
        inv_position = ik.forward_kinematics(state=state)
        print(f&#39;Forward Kinematics Position: {inv_position}&#39;)
        print(&#39;-------------------------------------------------------&#39;)
        diff = get_diff_xyz(for_position, inv_position)
        assert (diff &lt; 0.1), &#34;INVERSE VS FORWARDS KINEMATICS DIFFERENT, POSSIBLE BUG&#34;
        print(f&#34;Difference between forward and inverse: {diff}&#34;)

    plt.show(block=True)


if __name__ == &#34;__main__&#34;:
    test_ik()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="inverse_kinematics.test_ik"><code class="name flex">
<span>def <span class="ident">test_ik</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic test_ik that does both forward and backwards kinematics for a collection of manually defined joint positions,
asserting that the forward and kinematics position for the joint positions are roughly the same</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ik():
    &#34;&#34;&#34;
    Basic test_ik that does both forward and backwards kinematics for a collection of manually defined joint positions,
    asserting that the forward and kinematics position for the joint positions are roughly the same

    Returns:
        None
    &#34;&#34;&#34;
    # Basic test_ik doing both forward and backwards kinematics assuring both give the same value
    positions = [[0, 0, 0, 0], [pi / 2, 0, 0, pi / 2], [-pi / 2, 0, -pi / 2, -pi / 2]]
    ik = InverseKinematics()

    for pos in positions:
        ik.plot_state(pos)
        for_position = ik.forward_kinematics(pos)
        print(f&#39;Forward Kinematics Position: {for_position}&#39;)
        print(f&#39;Target: {pos}&#39;)
        state = ik.inverse_kinematics(target_position_xyz=for_position)
        print(f&#39;Required State Radians {state[3:7]}&#39;)
        inv_position = ik.forward_kinematics(state=state)
        print(f&#39;Forward Kinematics Position: {inv_position}&#39;)
        print(&#39;-------------------------------------------------------&#39;)
        diff = get_diff_xyz(for_position, inv_position)
        assert (diff &lt; 0.1), &#34;INVERSE VS FORWARDS KINEMATICS DIFFERENT, POSSIBLE BUG&#34;
        print(f&#34;Difference between forward and inverse: {diff}&#34;)

    plt.show(block=True)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="inverse_kinematics.InverseKinematics"><code class="flex name class">
<span>class <span class="ident">InverseKinematics</span></span>
<span>(</span><span>robot_obj=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the chain/urdf of the arm used for forward and inverse kinematics with the final end effector
being the center of the end of the fixed chopstick.
All measurements are in centimeters and have been measured
using the solidworks model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>robot_obj</code></strong> :&ensp;<code>Robot</code></dt>
<dd>Robot class which is needed for the joint min and max positions</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>bento_chain</code></strong> :&ensp;<code>Chain</code></dt>
<dd>IKPy Chain, a collection of links and __joints representing the bento arm</dd>
<dt><strong><code>max_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Total allowable IK lookup error ( goal_position - position calculated by IK )</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InverseKinematics:

    def __init__(self, robot_obj=None):
        &#34;&#34;&#34;
        This is the chain/urdf of the arm used for forward and inverse kinematics with the final end effector
        being the center of the end of the fixed chopstick.  All measurements are in centimeters and have been measured
        using the solidworks model.

        Args:
            robot_obj (Robot): Robot class which is needed for the joint min and max positions

        Attributes:
            bento_chain (Chain): IKPy Chain, a collection of links and __joints representing the bento arm
            max_error (float): Total allowable IK lookup error ( goal_position - position calculated by IK )
        &#34;&#34;&#34;

        if robot_obj is None:
            from robot import Robot
            self.robot = Robot()
        else:
            self.robot = robot_obj

        self.bento_chain = Chain(name=&#39;left_arm&#39;, links=[
            OriginLink(),
            URDFLink(
                name=&#34;base_to_post&#34;,
                origin_translation=[0, 0, 32],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;
            ),
            URDFLink(
                name=&#34;extender&#34;,
                origin_translation=[12, 0, 0],  # Careful this is set by the user
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;,
            ),
            URDFLink(
                name=&#34;shoulder&#34;,
                origin_translation=[0, 0, -6.99],
                origin_orientation=[pi, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 0, 1],
                bounds=(self.robot.get_joints()[0].radians_min, self.robot.get_joints()[0].radians_max)
            ),
            URDFLink(
                name=&#34;shoulder_to_elbow&#34;,
                origin_translation=[2.9, 0, 12.503],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 1, 0],
                bounds=(self.robot.get_joints()[1].radians_min, self.robot.get_joints()[1].radians_max)
            ),
            URDFLink(
                name=&#34;elbow_to_forearm&#34;,
                origin_translation=[15.123, 0, -0.225],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[1, 0, 0],
                bounds=(self.robot.get_joints()[2].radians_min, self.robot.get_joints()[2].radians_max)
            ),
            URDFLink(
                name=&#34;forearm_to_wrist&#34;,
                origin_translation=[4.38, 0, 0.065],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;revolute&#34;,
                rotation=[0, 1, 0],
                bounds=(self.robot.get_joints()[3].radians_min, self.robot.get_joints()[3].radians_max)
            ),
            URDFLink(
                name=&#34;wrist_to_hand&#34;,
                origin_translation=[8.43, 0, 0.073],
                origin_orientation=[pi, 0, 0],
                joint_type=&#34;fixed&#34;,
            ),
            URDFLink(
                name=&#34;hand_to_finger&#34;,
                origin_translation=[10.52, -0.092, 0],
                origin_orientation=[0, 0, 0],
                joint_type=&#34;fixed&#34;,
            ), ], active_links_mask=[False, False, False, True, True, True, True, False, False])

        # Ax for plotting
        self.ax = plt.figure().add_subplot(111, projection=&#39;3d&#39;)
        self.ax.axes.set_xlim3d(left=0, right=55)
        self.ax.axes.set_ylim3d(bottom=-22.5, top=22.5)
        self.ax.axes.set_zlim3d(bottom=0, top=55)

        # Safety params
        self.max_error = 0.1

    def plot_state(self, state=[0, 0, 0, 0]):
        &#34;&#34;&#34;
        Plots the Bento Arm in the given joint_positions in 3D

        Args:
            state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]

        Returns:
            None

        &#34;&#34;&#34;
        self.bento_chain.plot(fill_state(state), self.ax)
        plt.show(block=False)

    def forward_kinematics(self, state=[0, 0, 0, 0], matrix=False):
        &#34;&#34;&#34;
        Does a forward kinematics lookup taking a joint_positions and calculating where the end of the fixed chopstick is in space

        Args:
            state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]
            matrix (bool): If true end effector position gets returned as a homogenous matrix, else a XYZ tuple

        Returns:
            The end effectors position as homogenous matrix or XYZ tuple
        &#34;&#34;&#34;
        position = self.bento_chain.forward_kinematics(fill_state(state))
        if matrix:
            return position  # Return homogenous transform matrix
        else:
            return position[0][3], position[1][3], position[2][3]  # Return X Y Z coordinates

    def inverse_kinematics(self, target_position_xyz=(0, 0, 0), plot=True):
        &#34;&#34;&#34;
        A crude inverse kinematics lookup which estimates the joint positions needed to have the end effector reach a
        target position.  Will also check if the sum of the difference between goal and forward_kinematics calculation
        is greater than self.max_error if so will give an input warning.

        Args:
            target_position_xyz (tuple): Target XYZ position in space for end effector to touch
            plot (bool): If true will plot the joint configuration

        Returns:

        &#34;&#34;&#34;
        joints = self.bento_chain.inverse_kinematics(target_position_xyz)
        forward = self.forward_kinematics(joints)
        difference = []
        for i in range(3):
            difference.append(abs(target_position_xyz[i] - forward[i]))
        if sum(difference) &gt; self.max_error:
            input(f&#34;WARNING POSITION {target_position_xyz} REDUCED TO {forward} PRESS ENTER IF YOUR SURE!!!&#34;)
        if plot:
            self.plot_state(joints)
        return joints

    def get_end_effector_position(self):
        &#34;&#34;&#34;
        Converts the current joint positions read by the brachIOplexus packet / Robot class and calculates the position
        of the end effector in 3D space (cm)

        Returns:
            Tuple of position (cm) or Matrix

        &#34;&#34;&#34;
        if self.robot.normalized:
            joints_to_ik = [change_scale(old_min=0,
                                         old_max=1,
                                         new_min=self.robot.get_joints()[i].radians_min,
                                         new_max=self.robot.get_joints()[i].radians_max,
                                         value=self.robot.get_joints()[i].get_normalized_joint_position()) for i in range(4)]
        else:
            joints_to_ik = [change_scale(old_min=self.robot.DYNA_MIN,
                                         old_max=self.robot.DYNA_MAX,
                                         new_min=-pi,
                                         new_max=pi,
                                         value=self.robot.get_joints()[i].position) for i in range(4)]
        return self.forward_kinematics(joints_to_ik, matrix=False)

    def get_joints_for_goal_xyz(self, goal_xyz, hand_state=&#34;mid&#34;):
        &#34;&#34;&#34;
        Builds an action using the desired goal_xyz and hand_state

        Args:
            goal_xyz: XYZ goal position for end effector in cm
            hand_state: possible options include &#34;closed&#34;, &#34;mid&#34;, and &#34;open&#34;

        Returns:
            A collection of __joints required by the Robot class

        &#34;&#34;&#34;
        ik_radians = self.inverse_kinematics(goal_xyz)[3:8]
        ik_radians[-1] = self.robot.hand_states[hand_state]
        # IKPY returns in [-pi, pi], need in [0,4096] or [0,1]
        if self.robot.normalized:
            joints = [change_scale(old_min=self.robot.get_joints()[i].radians_min,
                                   old_max=self.robot.get_joints()[i].radians_max,
                                   new_min=0,
                                   new_max=1,
                                   value=ik_radians[i]) for i in range(5)]
            return joints

        else:
            return [change_scale(-pi, pi, self.robot.DYNA_MIN, self.robot.DYNA_MAX, i) for i in ik_radians]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="inverse_kinematics.InverseKinematics.forward_kinematics"><code class="name flex">
<span>def <span class="ident">forward_kinematics</span></span>(<span>self, state=[0, 0, 0, 0], matrix=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Does a forward kinematics lookup taking a joint_positions and calculating where the end of the fixed chopstick is in space</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>list</code></dt>
<dd>List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]</dd>
<dt><strong><code>matrix</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true end effector position gets returned as a homogenous matrix, else a XYZ tuple</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The end effectors position as homogenous matrix or XYZ tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward_kinematics(self, state=[0, 0, 0, 0], matrix=False):
    &#34;&#34;&#34;
    Does a forward kinematics lookup taking a joint_positions and calculating where the end of the fixed chopstick is in space

    Args:
        state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]
        matrix (bool): If true end effector position gets returned as a homogenous matrix, else a XYZ tuple

    Returns:
        The end effectors position as homogenous matrix or XYZ tuple
    &#34;&#34;&#34;
    position = self.bento_chain.forward_kinematics(fill_state(state))
    if matrix:
        return position  # Return homogenous transform matrix
    else:
        return position[0][3], position[1][3], position[2][3]  # Return X Y Z coordinates</code></pre>
</details>
</dd>
<dt id="inverse_kinematics.InverseKinematics.get_end_effector_position"><code class="name flex">
<span>def <span class="ident">get_end_effector_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the current joint positions read by the brachIOplexus packet / Robot class and calculates the position
of the end effector in 3D space (cm)</p>
<h2 id="returns">Returns</h2>
<p>Tuple of position (cm) or Matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_effector_position(self):
    &#34;&#34;&#34;
    Converts the current joint positions read by the brachIOplexus packet / Robot class and calculates the position
    of the end effector in 3D space (cm)

    Returns:
        Tuple of position (cm) or Matrix

    &#34;&#34;&#34;
    if self.robot.normalized:
        joints_to_ik = [change_scale(old_min=0,
                                     old_max=1,
                                     new_min=self.robot.get_joints()[i].radians_min,
                                     new_max=self.robot.get_joints()[i].radians_max,
                                     value=self.robot.get_joints()[i].get_normalized_joint_position()) for i in range(4)]
    else:
        joints_to_ik = [change_scale(old_min=self.robot.DYNA_MIN,
                                     old_max=self.robot.DYNA_MAX,
                                     new_min=-pi,
                                     new_max=pi,
                                     value=self.robot.get_joints()[i].position) for i in range(4)]
    return self.forward_kinematics(joints_to_ik, matrix=False)</code></pre>
</details>
</dd>
<dt id="inverse_kinematics.InverseKinematics.get_joints_for_goal_xyz"><code class="name flex">
<span>def <span class="ident">get_joints_for_goal_xyz</span></span>(<span>self, goal_xyz, hand_state='mid')</span>
</code></dt>
<dd>
<div class="desc"><p>Builds an action using the desired goal_xyz and hand_state</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>goal_xyz</code></strong></dt>
<dd>XYZ goal position for end effector in cm</dd>
<dt><strong><code>hand_state</code></strong></dt>
<dd>possible options include "closed", "mid", and "open"</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A collection of __joints required by the Robot class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_joints_for_goal_xyz(self, goal_xyz, hand_state=&#34;mid&#34;):
    &#34;&#34;&#34;
    Builds an action using the desired goal_xyz and hand_state

    Args:
        goal_xyz: XYZ goal position for end effector in cm
        hand_state: possible options include &#34;closed&#34;, &#34;mid&#34;, and &#34;open&#34;

    Returns:
        A collection of __joints required by the Robot class

    &#34;&#34;&#34;
    ik_radians = self.inverse_kinematics(goal_xyz)[3:8]
    ik_radians[-1] = self.robot.hand_states[hand_state]
    # IKPY returns in [-pi, pi], need in [0,4096] or [0,1]
    if self.robot.normalized:
        joints = [change_scale(old_min=self.robot.get_joints()[i].radians_min,
                               old_max=self.robot.get_joints()[i].radians_max,
                               new_min=0,
                               new_max=1,
                               value=ik_radians[i]) for i in range(5)]
        return joints

    else:
        return [change_scale(-pi, pi, self.robot.DYNA_MIN, self.robot.DYNA_MAX, i) for i in ik_radians]</code></pre>
</details>
</dd>
<dt id="inverse_kinematics.InverseKinematics.inverse_kinematics"><code class="name flex">
<span>def <span class="ident">inverse_kinematics</span></span>(<span>self, target_position_xyz=(0, 0, 0), plot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A crude inverse kinematics lookup which estimates the joint positions needed to have the end effector reach a
target position.
Will also check if the sum of the difference between goal and forward_kinematics calculation
is greater than self.max_error if so will give an input warning.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_position_xyz</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Target XYZ position in space for end effector to touch</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true will plot the joint configuration</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_kinematics(self, target_position_xyz=(0, 0, 0), plot=True):
    &#34;&#34;&#34;
    A crude inverse kinematics lookup which estimates the joint positions needed to have the end effector reach a
    target position.  Will also check if the sum of the difference between goal and forward_kinematics calculation
    is greater than self.max_error if so will give an input warning.

    Args:
        target_position_xyz (tuple): Target XYZ position in space for end effector to touch
        plot (bool): If true will plot the joint configuration

    Returns:

    &#34;&#34;&#34;
    joints = self.bento_chain.inverse_kinematics(target_position_xyz)
    forward = self.forward_kinematics(joints)
    difference = []
    for i in range(3):
        difference.append(abs(target_position_xyz[i] - forward[i]))
    if sum(difference) &gt; self.max_error:
        input(f&#34;WARNING POSITION {target_position_xyz} REDUCED TO {forward} PRESS ENTER IF YOUR SURE!!!&#34;)
    if plot:
        self.plot_state(joints)
    return joints</code></pre>
</details>
</dd>
<dt id="inverse_kinematics.InverseKinematics.plot_state"><code class="name flex">
<span>def <span class="ident">plot_state</span></span>(<span>self, state=[0, 0, 0, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the Bento Arm in the given joint_positions in 3D</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>list</code></dt>
<dd>List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_state(self, state=[0, 0, 0, 0]):
    &#34;&#34;&#34;
    Plots the Bento Arm in the given joint_positions in 3D

    Args:
        state (list): List of joint configurations in [-π,π]: [shoulder, elbow, forearm, wrist]

    Returns:
        None

    &#34;&#34;&#34;
    self.bento_chain.plot(fill_state(state), self.ax)
    plt.show(block=False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="inverse_kinematics.test_ik" href="#inverse_kinematics.test_ik">test_ik</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="inverse_kinematics.InverseKinematics" href="#inverse_kinematics.InverseKinematics">InverseKinematics</a></code></h4>
<ul class="">
<li><code><a title="inverse_kinematics.InverseKinematics.forward_kinematics" href="#inverse_kinematics.InverseKinematics.forward_kinematics">forward_kinematics</a></code></li>
<li><code><a title="inverse_kinematics.InverseKinematics.get_end_effector_position" href="#inverse_kinematics.InverseKinematics.get_end_effector_position">get_end_effector_position</a></code></li>
<li><code><a title="inverse_kinematics.InverseKinematics.get_joints_for_goal_xyz" href="#inverse_kinematics.InverseKinematics.get_joints_for_goal_xyz">get_joints_for_goal_xyz</a></code></li>
<li><code><a title="inverse_kinematics.InverseKinematics.inverse_kinematics" href="#inverse_kinematics.InverseKinematics.inverse_kinematics">inverse_kinematics</a></code></li>
<li><code><a title="inverse_kinematics.InverseKinematics.plot_state" href="#inverse_kinematics.InverseKinematics.plot_state">plot_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>